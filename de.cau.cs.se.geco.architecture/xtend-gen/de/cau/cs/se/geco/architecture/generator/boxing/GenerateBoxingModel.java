package de.cau.cs.se.geco.architecture.generator.boxing;

import de.cau.cs.se.geco.architecture.framework.IGenerator;
import de.cau.cs.se.geco.architecture.model.boxing.BoxingModel;
import de.cau.cs.se.geco.architecture.model.boxing.Group;
import de.cau.cs.se.geco.architecture.model.boxing.Unit;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.common.types.JvmType;

@SuppressWarnings("all")
public class GenerateBoxingModel /* implements IGenerator<GecoModel, BoxingModel>  */{
  @Override
  public BoxingModel generate(final /* GecoModel */Object input) {
    throw new Error("Unresolved compilation problems:"
      + "\nGenerator cannot be resolved to a type."
      + "\nWeaver cannot be resolved to a type."
      + "\nGenerator cannot be resolved to a type."
      + "\nGenerator cannot be resolved to a type."
      + "\nWeaver cannot be resolved to a type."
      + "\nThe method derivedFrom(GecoModel) is undefined for the type BoxingModel"
      + "\nThe method or field models is undefined for the type Object"
      + "\nThe method selector(Object) is undefined for the type ModelDeclaration"
      + "\nThe method or field type is undefined for the type Object"
      + "\nThe method model(Object) is undefined for the type ModelDeclaration"
      + "\nThe method modifier(Object) is undefined for the type ModelDeclaration"
      + "\nThe method or field modifier is undefined for the type Object"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nUnreachable code: The case can never match. It is already handled by a previous condition."
      + "\nUnreachable code: The case can never match. It is already handled by a previous condition."
      + "\nThe method createGenerator(Generator) from the type GenerateBoxingModel refers to the missing type Generator"
      + "\nThe method createGenerator(Generator) from the type GenerateBoxingModel refers to the missing type Generator"
      + "\nThe method createWeaver(Weaver) from the type GenerateBoxingModel refers to the missing type Weaver"
      + "\nThe method createGroup(EList<ModelSequence>) from the type GenerateBoxingModel refers to the missing type ModelSequence"
      + "\nmodels cannot be resolved"
      + "\nforEach cannot be resolved"
      + "\nforEach cannot be resolved"
      + "\nfragments cannot be resolved"
      + "\nforEach cannot be resolved"
      + "\naspectModel cannot be resolved"
      + "\naspectModel cannot be resolved"
      + "\nreference cannot be resolved"
      + "\naspectModel cannot be resolved"
      + "\n== cannot be resolved"
      + "\nreference cannot be resolved"
      + "\nmodels cannot be resolved");
  }
  
  private void print(final Group group) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field sourceTraceModels is undefined for the type Group"
      + "\nThe method determineTraceModel(TargetTraceModel) from the type GenerateBoxingModel refers to the missing type TraceModel"
      + "\nmap cannot be resolved"
      + "\nname cannot be resolved"
      + "\njoin cannot be resolved");
  }
  
  private void print(final Unit unit) {
    throw new Error("Unresolved compilation problems:"
      + "\nGenerator cannot be resolved to a type."
      + "\nWeaver cannot be resolved to a type."
      + "\nThe method or field fragment is undefined for the type Unit"
      + "\nUnreachable code: The case can never match. It is already handled by a previous condition."
      + "\nThe method determineTraceModel(TargetTraceModel) from the type GenerateBoxingModel refers to the missing type TraceModel"
      + "\nreference cannot be resolved"
      + "\nqualifiedName cannot be resolved"
      + "\ntargetTraceModel cannot be resolved"
      + "\n!= cannot be resolved"
      + "\ntargetTraceModel cannot be resolved"
      + "\ndetermineTraceModel cannot be resolved"
      + "\nname cannot be resolved"
      + "\nsourceTraceModels cannot be resolved"
      + "\n!= cannot be resolved"
      + "\nsourceTraceModels cannot be resolved"
      + "\nmap cannot be resolved"
      + "\nname cannot be resolved"
      + "\njoin cannot be resolved"
      + "\nreference cannot be resolved"
      + "\nqualifiedName cannot be resolved");
  }
  
  /**
   * Check if the given group provides the necessary inputs for the unit.
   */
  private boolean matchGroup(final Unit unit, final Group group) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field sourceModels is undefined for the type Unit"
      + "\nThe method or field sourceModels is undefined for the type Group"
      + "\nThe method or field sourceTraceModels is undefined for the type Unit"
      + "\nThe method or field sourceTraceModels is undefined for the type Group"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nforall cannot be resolved"
      + "\nexists cannot be resolved"
      + "\n&& cannot be resolved"
      + "\nforall cannot be resolved"
      + "\nexists cannot be resolved");
  }
  
  /**
   * Create a new group based on a sequence of free metamodels.
   */
  private Group createGroup(final /* EList<ModelSequence> */Object metamodels) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field modifier is undefined for the type Object"
      + "\nThe method or field ModelModifier is undefined"
      + "\nThe method or field models is undefined for the type Object"
      + "\nThe method or field sourceModels is undefined for the type Group"
      + "\n== cannot be resolved"
      + "\nINPUT cannot be resolved"
      + "\nforEach cannot be resolved"
      + "\nadd cannot be resolved");
  }
  
  /**
   * Create a new group based on the previous groups inputs and all outputs of its units.
   */
  private Group createGroup(final Group oldGroup) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field sourceModels is undefined for the type Group"
      + "\nThe method or field sourceModels is undefined for the type Group"
      + "\nThe method or field sourceTraceModels is undefined for the type Group"
      + "\nThe method or field sourceTraceModels is undefined for the type Group"
      + "\nThe method or field sourceModels is undefined for the type Group"
      + "\nThe method or field targetModel is undefined for the type Unit"
      + "\nThe method or field targetTraceModel is undefined for the type Unit"
      + "\nThe method or field sourceTraceModels is undefined for the type Group"
      + "\nThe method or field targetTraceModel is undefined for the type Unit"
      + "\naddAll cannot be resolved"
      + "\naddAll cannot be resolved"
      + "\naddUnique cannot be resolved"
      + "\n!= cannot be resolved"
      + "\naddUnique cannot be resolved");
  }
  
  /**
   * create a unit node for a generator.
   */
  private Unit createGenerator(final /* Generator */Object generator) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method fragment(Generator) is undefined for the type Unit"
      + "\nThe method or field sourceModels is undefined for the type Unit"
      + "\nThe method or field sourceModels is undefined for the type Unit"
      + "\nThe method or field reference is undefined for the type Object"
      + "\nThe method or field sourceTraceModels is undefined for the type Unit"
      + "\nThe method targetModel(Object) is undefined for the type Unit"
      + "\nThe method targetTraceModel(Object) is undefined for the type Unit"
      + "\nThe method targetTraceModel(Object) is undefined for the type Unit"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nsourceModel cannot be resolved"
      + "\nreference cannot be resolved"
      + "\n!= cannot be resolved"
      + "\nadd cannot be resolved"
      + "\nsourceModel cannot be resolved"
      + "\nreference cannot be resolved"
      + "\nsourceAuxModels cannot be resolved"
      + "\nforEach cannot be resolved"
      + "\naddUnique cannot be resolved"
      + "\naddAllUnique cannot be resolved"
      + "\nsourceTraceModels cannot be resolved"
      + "\ntargetModel cannot be resolved"
      + "\nreference cannot be resolved"
      + "\ntargetTraceModel cannot be resolved"
      + "\n!= cannot be resolved"
      + "\ntargetTraceModel cannot be resolved"
      + "\ndetermineTraceModel cannot be resolved"
      + "\nreference cannot be resolved"
      + "\nreference cannot be resolved");
  }
  
  /**
   * create a unit node for a weaver-generator combination.
   */
  private Unit createGenerator(final /* Weaver */Object weaver) {
    throw new Error("Unresolved compilation problems:"
      + "\nGenerator cannot be resolved to a type."
      + "\nThe method fragment(Weaver) is undefined for the type Unit"
      + "\nThe method or field sourceModels is undefined for the type Unit"
      + "\nThe method or field sourceModels is undefined for the type Unit"
      + "\nThe method or field reference is undefined for the type Object"
      + "\nThe method or field sourceTraceModels is undefined for the type Unit"
      + "\nThe method targetModel(Object) is undefined for the type Unit"
      + "\nThe method or field sourceModels is undefined for the type Unit"
      + "\nThe method or field targetModel is undefined for the type Unit"
      + "\nThe method targetTraceModel(Object) is undefined for the type Unit"
      + "\nThe method targetTraceModel(Object) is undefined for the type Unit"
      + "\nThere is no context to infer the closure\'s argument types from. Consider typing the arguments or put the closures into a typed context."
      + "\nThe method resolveWeaverSourceModel(Weaver) from the type ArchitectureTyping refers to the missing type SourceModelSelector"
      + "\naspectModel cannot be resolved"
      + "\nadd cannot be resolved"
      + "\nsourceModel cannot be resolved"
      + "\nreference cannot be resolved"
      + "\nsourceAuxModels cannot be resolved"
      + "\nforEach cannot be resolved"
      + "\naddUnique cannot be resolved"
      + "\naddAllUnique cannot be resolved"
      + "\nsourceTraceModels cannot be resolved"
      + "\nreference cannot be resolved"
      + "\naddUnique cannot be resolved"
      + "\ntargetTraceModel cannot be resolved"
      + "\n!= cannot be resolved"
      + "\ntargetTraceModel cannot be resolved"
      + "\ndetermineTraceModel cannot be resolved"
      + "\nreference cannot be resolved"
      + "\nreference cannot be resolved");
  }
  
  /**
   * create a unit node for a weaver.
   */
  private Unit createWeaver(final /* Weaver */Object weaver) {
    throw new Error("Unresolved compilation problems:"
      + "\nTargetModel cannot be resolved to a type."
      + "\nThe method fragment(Weaver) is undefined for the type Unit"
      + "\nThe method or field sourceModels is undefined for the type Unit"
      + "\nThe method or field sourceModels is undefined for the type Unit"
      + "\nThe method targetModel(Object) is undefined for the type Unit"
      + "\nThe method targetTraceModel(Object) is undefined for the type Unit"
      + "\nThe method resolveWeaverSourceModel(Weaver) from the type ArchitectureTyping refers to the missing type SourceModelSelector"
      + "\nadd cannot be resolved"
      + "\nsourceModel cannot be resolved"
      + "\nreference cannot be resolved"
      + "\nadd cannot be resolved"
      + "\naspectModel cannot be resolved"
      + "\nreference cannot be resolved"
      + "\nreference cannot be resolved");
  }
  
  /**
   * Determine the trace model.
   */
  private /* TraceModel */Object determineTraceModel(final /* TargetTraceModel */Object model) {
    throw new Error("Unresolved compilation problems:"
      + "\nTraceModel cannot be resolved to a type."
      + "\nTraceModelReference cannot be resolved to a type."
      + "\nUnreachable code: The case can never match. It is already handled by a previous condition."
      + "\ntraceModel cannot be resolved");
  }
  
  /**
   * Add a list of trace model to a trace model list. Check for each element if it is
   * already in the list. If so do not add it again.
   */
  private void addAllUnique(final /* EList<TraceModel> */Object list, final /* EList<TraceModelReference> */Object insert) {
    throw new Error("Unresolved compilation problems:"
      + "\nThe method or field traceModel is undefined for the type Object"
      + "\nThe method addUnique(EList<TraceModel>, TraceModel) from the type GenerateBoxingModel refers to the missing type TraceModel");
  }
  
  /**
   * Add a write trace model if it is not already in the list.
   */
  private void addUnique(final /* EList<TraceModel> */Object list, final /* TraceModel */Object model) {
    boolean _contains = list.contains(model);
    boolean _not = (!_contains);
    if (_not) {
      list.add(model);
    }
  }
  
  /**
   * Add a write trace model if it is not already in the list.
   */
  private void addUnique(final /* EList<Model> */Object list, final /* Model */Object model) {
    boolean _contains = list.contains(model);
    boolean _not = (!_contains);
    if (_not) {
      list.add(model);
    }
  }
  
  /**
   * Add a JvmType to a list if it is not already listed.
   */
  private void addUniqueType(final EList<JvmType> list, final JvmType type) {
    boolean _contains = list.contains(type);
    boolean _not = (!_contains);
    if (_not) {
      list.add(type);
    }
  }
}
