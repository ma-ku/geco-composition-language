grammar de.cau.cs.se.geco.architecture.Architecture with org.eclipse.xtext.common.Terminals

generate architecture "http://www.cau.de/cs/se/geco/architecture/Architecture"
import "http://www.eclipse.org/xtext/common/JavaVMTypes" as types

Model:
	'package' name=QualifiedName
	imports+=Import*
	registeredPackages+=RegisteredPackage*
	metamodels+=MetamodelSequence*	
	connections+=Connection*
;

Import:
	'import' importedNamespace = [types::JvmType|QualifiedName]
;

MetamodelSequence:
	'model' type=ModelNodeType metamodels+=Metamodel (',' metamodels+=Metamodel)*
;

Metamodel:
	name=ID 
;

RegisteredPackage:
	'register' name=ID (importedNamespace = [types::JvmType|QualifiedName] |(isText?='text' extension=STRING))
;

Connection:
	Generator | Weaver
;

Weaver:
	'weave' reference=[types::JvmType|ID]  
		(sourceModel=SourceModelNodeSelector|'link')
		aspectModel=AspectModel
		('=>' targetModel=TargetModelNodeType)?
;

AspectModel:
	(':' TargetModelNodeType) | Generator
;
	
Generator:
	'generate' reference=[types::JvmType|ID] 
		sourceModel=SourceModelNodeSelector
		targetModel=TargetModelNodeType
		('->' writeTraceModel=WriteTraceModel)?
		('<-' readTraceModels+=TraceModelReference (',' readTraceModels+=TraceModelReference)*)?
;


SourceModelNodeSelector: 
	reference = [Metamodel|ID]  ('[' constraint=ConstraintExpression ']')? ('/' property=NodeProperty)? | 
	{SourceModelNodeSelector} 'null' 
;

TargetModelNodeType: {TargetModelNodeType}
	(reference = [Metamodel|ID])?
;

ModelNodeType:
	target=[RegisteredPackage|ID] ('/' property=NodeProperty)?
;

NodeProperty:
	property=[types::JvmMember|ID] ('[' constraint=ConstraintExpression ']')? ('/' subProperty=NodeProperty)? 
;

ConstraintExpression:
	CompareExpression (=>({ConstraintExpression.left=current} operator=LogicOperator) right=ConstraintExpression)?
;

CompareExpression:
	BasicConstraint (=>({CompareExpression.left=current} comparator=Comparator) right=BasicConstraint)?
;

BasicConstraint:
	ParenthesisConstraint |
	Operand |
	Negation
;

Negation:
	'!' constraint = ConstraintExpression
;

ParenthesisConstraint:
	'(' constraint = ConstraintExpression ')'
;

Operand:
	Literal | NodeProperty | Typeof
;

Typeof:
	'typeof' type = [types::JvmType|ID] 	
;

WriteTraceModel:
	TraceModel | 'use' TraceModelReference
;

TraceModelReference:
	traceModel = [TraceModel|ID]
;

TraceModel:
	name=ID '<' nodeSetRelations+=NodeSetRelation+ '>'
;

NodeSetRelation:
	'(' 
		sourceNodes+=NodeType (',' sourceNodes+=NodeType)*
	':' 
		targetNodes+=NodeType (',' targetNodes+=NodeType)* 
	')'
;

NodeType: type = [types::JvmType|ID] ;

// -----------------------------------
// Literal

Literal:
	StringLiteral | IntLiteral | FloatLiteral | BooleanLiteral | ArrayLiteral
;

ArrayLiteral:
	'{' literals+=Literal (',' literals+=Literal)* '}'
;

StringLiteral:
	value=STRING
;

IntLiteral:
	value=INT
;

FloatLiteral:
	value=FLOAT
;

BooleanLiteral: 
	value=BOOLEAN
;

// -----------------------------------
// Terminals

enum LogicOperator:
	AND = '&' |
	OR = '|'
;

enum Comparator:
	EQ = '==' |
	NE = '!=' |
	GR = '>' |
	LW = '<' |
	GE = '>=' |
	LE = '<=' |
	LIKE = '~'
;

QualifiedName:
  ID (=>'.' ID)*;

QualifiedNameWithWildcard:
	QualifiedName ('.' '*')?
;

// terminals
terminal fragment DIGIT :
    '0'..'9';
   
// make sure the Float rule does not shadow the INT rule
terminal FLOAT:
    '-'? DIGIT+ ('.' DIGIT*) (("e"|"E") ("+"|"-")? DIGIT+)? 'f'? |
    '-'? DIGIT+ 'f';
    
// introduce boolean values
terminal BOOLEAN:
    'true' | 'false';