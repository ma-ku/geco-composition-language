grammar de.cau.cs.se.geco.architecture.Architecture with org.eclipse.xtext.common.Terminals

generate architecture "http://www.cau.de/cs/se/geco/architecture/Architecture"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	'package' name=QualifiedName
	'import' imports+=Import*
	registeredPackages+=RegisteredPackage+
	
	// prerequisites
	// handle results
	(connections+=Connection | metamodels+=MetamodelSequence)*
;

Import:
	WeaverImport | GeneratorImport
;

WeaverImport:
	'weave' importedNamespace = QualifiedNameWithWildcard
;

GeneratorImport:
	'gen' importedNamespace = QualifiedNameWithWildcard
;

MetamodelSequence:
	'model' type=ModelNodeType metamodels+=Metamodel (',' metamodels+=Metamodel)*
;

Metamodel:
	name=ID 
;

RegisteredPackage:
	'register' name=ID (modelPackage=[ecore::EPackage|STRING] |(isText?='text' extension=STRING))
;

Connection:
	Generator | Weaver
;

Weaver:
	'weave' weaver=[WeaverImport|ID]  
		sourceModel=SourceModelNodeSelector
		aspectModel=AspectModel
		('=>' targetModel=TargetModelNodeType)?
;

AspectModel:
	(':' TargetModelNodeType) | Generator
;
	
Generator:
	'generate' generator=[GeneratorImport|ID] 
		sourceModel=SourceModelNodeSelector
		targetModel=TargetModelNodeType
		('->' writeTraceModel=TraceModel)?
		('<-' readTraceModels+=[TraceModel|ID] (',' readTraceModels+=[TraceModel|ID])*)?
;

SourceModelNodeSelector: 
	reference = [Metamodel|ID] ('/' property=NodeProperty)? | 
	{SourceModelNodeSelector} 'null' 
;

TargetModelNodeType: {TargetModelNodeType}
	(reference = [Metamodel|ID])? (multiply?='*')?
;

ModelNodeType:
	target=[RegisteredPackage|ID] '/' type=[ecore::EClass|ID] ('/' property=NodeProperty)?
;

NodeProperty:
	property=[ecore::EReference|ID] ('[' constraint=ConstraintExpression ']')? ('/' subProperty=NodeProperty)? 
;

ConstraintExpression:
	CompareExpression (=>({ConstraintExpression.left=current} operator=LogicOperator) right=ConstraintExpression)?
;

CompareExpression returns ConstraintExpression:
	BasicConstraint (=>({ConstraintExpression.left=current} operator=Comparator) right=BasicConstraint)?
;

BasicConstraint returns ConstraintExpression:
	ParenthesisConstraint |
	Operand
;

ParenthesisConstraint returns ConstraintExpression:
	'(' constraint=ConstraintExpression ')'
;

Operand:
	Literal | NodeProperty
;

TraceModel:
	name=ID '<' nodeSetRelations+=NodeSetRelation+ '>'
;

NodeSetRelation:
	'(' 
		sourceNodes+=NodeType (',' sourceNodes+=NodeType)*
	':' 
		targetNodes+=NodeType (',' targetNodes+=NodeType)* 
	')'
;

NodeType: eclass=[ecore::EClass|ID];

// -----------------------------------
// Literal

Literal:
	StringLiteral | IntLiteral | FloatLiteral | BooleanLiteral | ArrayLiteral
;

ArrayLiteral:
	'{' literals+=Literal (',' literals+=Literal)* '}'
;

StringLiteral:
	value=STRING
;

IntLiteral:
	value=INT
;

FloatLiteral:
	value=FLOAT
;

BooleanLiteral: 
	value=BOOLEAN
;

// -----------------------------------
// Terminals

LogicOperator:
	AND = '&' |
	OR = '|'
;

Comparator:
	EQ = '==' |
	NE = '!=' |
	GR = '>' |
	LW = '<' |
	GE = '>=' |
	LE = '<=' |
	LIKE = '~'
;

QualifiedName:
  ID (=>'.' ID)*;

QualifiedNameWithWildcard:
	QualifiedName ('.' '*')?
;

// terminals
terminal fragment DIGIT :
    '0'..'9';
   
// redefine INT terminal to allow negative numbers
terminal INT returns ecore::EInt:
    '-'? DIGIT+;

// make sure the Float rule does not shadow the INT rule
terminal FLOAT returns ecore::EFloatObject :
    '-'? DIGIT+ ('.' DIGIT*) (("e"|"E") ("+"|"-")? DIGIT+)? 'f'? |
    '-'? DIGIT+ 'f';
    
// introduce boolean values
terminal BOOLEAN returns ecore::EBooleanObject :
    'true' | 'false';