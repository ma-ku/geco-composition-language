/*
 * generated by Xtext
 */
package de.cau.cs.se.geco.architecture.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import de.cau.cs.se.geco.architecture.architecture.ArchitecturePackage;
import de.cau.cs.se.geco.architecture.architecture.ArrayLiteral;
import de.cau.cs.se.geco.architecture.architecture.BooleanLiteral;
import de.cau.cs.se.geco.architecture.architecture.CompareExpression;
import de.cau.cs.se.geco.architecture.architecture.ConstraintExpression;
import de.cau.cs.se.geco.architecture.architecture.FloatLiteral;
import de.cau.cs.se.geco.architecture.architecture.GecoModel;
import de.cau.cs.se.geco.architecture.architecture.Generator;
import de.cau.cs.se.geco.architecture.architecture.Import;
import de.cau.cs.se.geco.architecture.architecture.IntLiteral;
import de.cau.cs.se.geco.architecture.architecture.Model;
import de.cau.cs.se.geco.architecture.architecture.ModelNodeType;
import de.cau.cs.se.geco.architecture.architecture.ModelSequence;
import de.cau.cs.se.geco.architecture.architecture.Negation;
import de.cau.cs.se.geco.architecture.architecture.NodeProperty;
import de.cau.cs.se.geco.architecture.architecture.NodeSetRelation;
import de.cau.cs.se.geco.architecture.architecture.NodeType;
import de.cau.cs.se.geco.architecture.architecture.ParenthesisConstraint;
import de.cau.cs.se.geco.architecture.architecture.RegisteredRootClass;
import de.cau.cs.se.geco.architecture.architecture.SeparatePointcutAdviceModel;
import de.cau.cs.se.geco.architecture.architecture.SourceModelNodeSelector;
import de.cau.cs.se.geco.architecture.architecture.StringLiteral;
import de.cau.cs.se.geco.architecture.architecture.TargetModelNodeType;
import de.cau.cs.se.geco.architecture.architecture.TraceModel;
import de.cau.cs.se.geco.architecture.architecture.TraceModelReference;
import de.cau.cs.se.geco.architecture.architecture.Typeof;
import de.cau.cs.se.geco.architecture.architecture.Weaver;
import de.cau.cs.se.geco.architecture.services.ArchitectureGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ArchitectureSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ArchitectureGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == ArchitecturePackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ArchitecturePackage.ARRAY_LITERAL:
				sequence_ArrayLiteral(context, (ArrayLiteral) semanticObject); 
				return; 
			case ArchitecturePackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case ArchitecturePackage.COMPARE_EXPRESSION:
				sequence_CompareExpression(context, (CompareExpression) semanticObject); 
				return; 
			case ArchitecturePackage.CONSTRAINT_EXPRESSION:
				sequence_ConstraintExpression(context, (ConstraintExpression) semanticObject); 
				return; 
			case ArchitecturePackage.FLOAT_LITERAL:
				sequence_FloatLiteral(context, (FloatLiteral) semanticObject); 
				return; 
			case ArchitecturePackage.GECO_MODEL:
				sequence_GecoModel(context, (GecoModel) semanticObject); 
				return; 
			case ArchitecturePackage.GENERATOR:
				sequence_Generator(context, (Generator) semanticObject); 
				return; 
			case ArchitecturePackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case ArchitecturePackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case ArchitecturePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ArchitecturePackage.MODEL_NODE_TYPE:
				sequence_ModelNodeType(context, (ModelNodeType) semanticObject); 
				return; 
			case ArchitecturePackage.MODEL_SEQUENCE:
				sequence_ModelSequence(context, (ModelSequence) semanticObject); 
				return; 
			case ArchitecturePackage.NEGATION:
				sequence_Negation(context, (Negation) semanticObject); 
				return; 
			case ArchitecturePackage.NODE_PROPERTY:
				sequence_NodeProperty(context, (NodeProperty) semanticObject); 
				return; 
			case ArchitecturePackage.NODE_SET_RELATION:
				sequence_NodeSetRelation(context, (NodeSetRelation) semanticObject); 
				return; 
			case ArchitecturePackage.NODE_TYPE:
				sequence_NodeType(context, (NodeType) semanticObject); 
				return; 
			case ArchitecturePackage.PARENTHESIS_CONSTRAINT:
				sequence_ParenthesisConstraint(context, (ParenthesisConstraint) semanticObject); 
				return; 
			case ArchitecturePackage.REGISTERED_ROOT_CLASS:
				sequence_RegisteredRootClass(context, (RegisteredRootClass) semanticObject); 
				return; 
			case ArchitecturePackage.SEPARATE_POINTCUT_ADVICE_MODEL:
				sequence_SeparatePointcutAdviceModel(context, (SeparatePointcutAdviceModel) semanticObject); 
				return; 
			case ArchitecturePackage.SOURCE_MODEL_NODE_SELECTOR:
				sequence_SourceModelNodeSelector(context, (SourceModelNodeSelector) semanticObject); 
				return; 
			case ArchitecturePackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case ArchitecturePackage.TARGET_MODEL_NODE_TYPE:
				sequence_TargetModelNodeType(context, (TargetModelNodeType) semanticObject); 
				return; 
			case ArchitecturePackage.TRACE_MODEL:
				sequence_TraceModel(context, (TraceModel) semanticObject); 
				return; 
			case ArchitecturePackage.TRACE_MODEL_REFERENCE:
				sequence_TraceModelReference(context, (TraceModelReference) semanticObject); 
				return; 
			case ArchitecturePackage.TYPEOF:
				sequence_Typeof(context, (Typeof) semanticObject); 
				return; 
			case ArchitecturePackage.WEAVER:
				sequence_Weaver(context, (Weaver) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (literals+=Literal literals+=Literal*)
	 */
	protected void sequence_ArrayLiteral(EObject context, ArrayLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_BooleanLiteral(EObject context, BooleanLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=CompareExpression_CompareExpression_1_0_0_0 comparator=Comparator right=BasicConstraint)
	 */
	protected void sequence_CompareExpression(EObject context, CompareExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=ConstraintExpression_ConstraintExpression_1_0_0_0 operator=LogicOperator right=ConstraintExpression)
	 */
	protected void sequence_ConstraintExpression(EObject context, ConstraintExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__LEFT));
			if(transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__OPERATOR));
			if(transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getConstraintExpressionAccess().getConstraintExpressionLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConstraintExpressionAccess().getOperatorLogicOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getConstraintExpressionAccess().getRightConstraintExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_FloatLiteral(EObject context, FloatLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=QualifiedName imports+=Import* registeredRootClass+=RegisteredRootClass* models+=ModelSequence* fragments+=Fragment*)
	 */
	protected void sequence_GecoModel(EObject context, GecoModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         reference=[JvmType|ID] 
	 *         (sourceAuxModels+=SourceModelNodeSelector sourceAuxModels+=SourceModelNodeSelector*)? 
	 *         sourceModel=SourceModelNodeSelector 
	 *         targetModel=TargetModelNodeType? 
	 *         (targetTraceModel=TargetTraceModel? (sourceTraceModels+=TraceModelReference sourceTraceModels+=TraceModelReference*)?)?
	 *     )
	 */
	protected void sequence_Generator(EObject context, Generator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     importedNamespace=[JvmType|QualifiedName]
	 */
	protected void sequence_Import(EObject context, Import semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceJvmTypeQualifiedNameParserRuleCall_1_0_1(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntLiteral(EObject context, IntLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (target=[RegisteredRootClass|ID] property=NodeProperty? collection?='[]'?)
	 */
	protected void sequence_ModelNodeType(EObject context, ModelNodeType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (modifier=ModelModifier type=ModelNodeType models+=Model models+=Model*)
	 */
	protected void sequence_ModelSequence(EObject context, ModelSequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.MODEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.MODEL__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getModelAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     constraint=ConstraintExpression
	 */
	protected void sequence_Negation(EObject context, Negation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (property=[JvmMember|ID] constraint=ConstraintExpression? subProperty=NodeProperty?)
	 */
	protected void sequence_NodeProperty(EObject context, NodeProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (sourceNodes+=NodeType sourceNodes+=NodeType* targetNodes+=NodeType targetNodes+=NodeType*)
	 */
	protected void sequence_NodeSetRelation(EObject context, NodeSetRelation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type=[JvmType|ID]
	 */
	protected void sequence_NodeType(EObject context, NodeType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.NODE_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.NODE_TYPE__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getNodeTypeAccess().getTypeJvmTypeIDTerminalRuleCall_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     constraint=ConstraintExpression
	 */
	protected void sequence_ParenthesisConstraint(EObject context, ParenthesisConstraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (importedNamespace=[JvmType|QualifiedName] | (isText?='text' extension=STRING)))
	 */
	protected void sequence_RegisteredRootClass(EObject context, RegisteredRootClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (pointcut=TargetModelNodeType advice=AdviceModel)
	 */
	protected void sequence_SeparatePointcutAdviceModel(EObject context, SeparatePointcutAdviceModel semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.SEPARATE_POINTCUT_ADVICE_MODEL__POINTCUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.SEPARATE_POINTCUT_ADVICE_MODEL__POINTCUT));
			if(transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.SEPARATE_POINTCUT_ADVICE_MODEL__ADVICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.SEPARATE_POINTCUT_ADVICE_MODEL__ADVICE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getSeparatePointcutAdviceModelAccess().getPointcutTargetModelNodeTypeParserRuleCall_1_0(), semanticObject.getPointcut());
		feeder.accept(grammarAccess.getSeparatePointcutAdviceModelAccess().getAdviceAdviceModelParserRuleCall_3_0(), semanticObject.getAdvice());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {SourceModelNodeSelector}
	 */
	protected void sequence_SourceModelNodeSelector(EObject context, SourceModelNodeSelector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(EObject context, StringLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     reference=[Model|ID]
	 */
	protected void sequence_TargetModelNodeType(EObject context, TargetModelNodeType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.TARGET_MODEL_NODE_TYPE__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.TARGET_MODEL_NODE_TYPE__REFERENCE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTargetModelNodeTypeAccess().getReferenceModelIDTerminalRuleCall_1_0_1(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     traceModel=[TraceModel|ID]
	 */
	protected void sequence_TraceModelReference(EObject context, TraceModelReference semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.TRACE_MODEL_REFERENCE__TRACE_MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.TRACE_MODEL_REFERENCE__TRACE_MODEL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getTraceModelReferenceAccess().getTraceModelTraceModelIDTerminalRuleCall_0_1(), semanticObject.getTraceModel());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID nodeSetRelations+=NodeSetRelation+)
	 */
	protected void sequence_TraceModel(EObject context, TraceModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type=[JvmType|ID]
	 */
	protected void sequence_Typeof(EObject context, Typeof semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (reference=[JvmType|ID] sourceModel=SourceModelNodeSelector? aspectModel=AspectModel targetModel=TargetModelNodeType?)
	 */
	protected void sequence_Weaver(EObject context, Weaver semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
