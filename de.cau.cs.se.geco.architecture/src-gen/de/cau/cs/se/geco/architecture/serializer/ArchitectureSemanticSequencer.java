/*
 * generated by Xtext 2.10.0
 */
package de.cau.cs.se.geco.architecture.serializer;

import com.google.inject.Inject;
import de.cau.cs.se.geco.architecture.architecture.ArchitecturePackage;
import de.cau.cs.se.geco.architecture.architecture.ArrayLiteral;
import de.cau.cs.se.geco.architecture.architecture.BooleanLiteral;
import de.cau.cs.se.geco.architecture.architecture.CompareExpression;
import de.cau.cs.se.geco.architecture.architecture.ConstraintExpression;
import de.cau.cs.se.geco.architecture.architecture.FloatLiteral;
import de.cau.cs.se.geco.architecture.architecture.GecoModel;
import de.cau.cs.se.geco.architecture.architecture.Generator;
import de.cau.cs.se.geco.architecture.architecture.Import;
import de.cau.cs.se.geco.architecture.architecture.InstanceOf;
import de.cau.cs.se.geco.architecture.architecture.IntLiteral;
import de.cau.cs.se.geco.architecture.architecture.Model;
import de.cau.cs.se.geco.architecture.architecture.ModelSequence;
import de.cau.cs.se.geco.architecture.architecture.ModelType;
import de.cau.cs.se.geco.architecture.architecture.Negation;
import de.cau.cs.se.geco.architecture.architecture.NodeProperty;
import de.cau.cs.se.geco.architecture.architecture.NodeSetRelation;
import de.cau.cs.se.geco.architecture.architecture.NodeType;
import de.cau.cs.se.geco.architecture.architecture.ParenthesisConstraint;
import de.cau.cs.se.geco.architecture.architecture.RegisteredRootClass;
import de.cau.cs.se.geco.architecture.architecture.SeparateModels;
import de.cau.cs.se.geco.architecture.architecture.SourceModelSelector;
import de.cau.cs.se.geco.architecture.architecture.StringLiteral;
import de.cau.cs.se.geco.architecture.architecture.TargetModel;
import de.cau.cs.se.geco.architecture.architecture.TraceModel;
import de.cau.cs.se.geco.architecture.architecture.TraceModelReference;
import de.cau.cs.se.geco.architecture.architecture.Weaver;
import de.cau.cs.se.geco.architecture.services.ArchitectureGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ArchitectureSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ArchitectureGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ArchitecturePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ArchitecturePackage.ARRAY_LITERAL:
				sequence_ArrayLiteral(context, (ArrayLiteral) semanticObject); 
				return; 
			case ArchitecturePackage.BOOLEAN_LITERAL:
				sequence_BooleanLiteral(context, (BooleanLiteral) semanticObject); 
				return; 
			case ArchitecturePackage.COMPARE_EXPRESSION:
				sequence_CompareExpression(context, (CompareExpression) semanticObject); 
				return; 
			case ArchitecturePackage.CONSTRAINT_EXPRESSION:
				sequence_ConstraintExpression(context, (ConstraintExpression) semanticObject); 
				return; 
			case ArchitecturePackage.FLOAT_LITERAL:
				sequence_FloatLiteral(context, (FloatLiteral) semanticObject); 
				return; 
			case ArchitecturePackage.GECO_MODEL:
				sequence_GecoModel(context, (GecoModel) semanticObject); 
				return; 
			case ArchitecturePackage.GENERATOR:
				sequence_Generator(context, (Generator) semanticObject); 
				return; 
			case ArchitecturePackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case ArchitecturePackage.INSTANCE_OF:
				sequence_InstanceOf(context, (InstanceOf) semanticObject); 
				return; 
			case ArchitecturePackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case ArchitecturePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ArchitecturePackage.MODEL_SEQUENCE:
				sequence_ModelSequence(context, (ModelSequence) semanticObject); 
				return; 
			case ArchitecturePackage.MODEL_TYPE:
				sequence_ModelType(context, (ModelType) semanticObject); 
				return; 
			case ArchitecturePackage.NEGATION:
				sequence_Negation(context, (Negation) semanticObject); 
				return; 
			case ArchitecturePackage.NODE_PROPERTY:
				sequence_NodeProperty(context, (NodeProperty) semanticObject); 
				return; 
			case ArchitecturePackage.NODE_SET_RELATION:
				sequence_NodeSetRelation(context, (NodeSetRelation) semanticObject); 
				return; 
			case ArchitecturePackage.NODE_TYPE:
				sequence_NodeType(context, (NodeType) semanticObject); 
				return; 
			case ArchitecturePackage.PARENTHESIS_CONSTRAINT:
				sequence_ParenthesisConstraint(context, (ParenthesisConstraint) semanticObject); 
				return; 
			case ArchitecturePackage.REGISTERED_ROOT_CLASS:
				sequence_RegisteredRootClass(context, (RegisteredRootClass) semanticObject); 
				return; 
			case ArchitecturePackage.SEPARATE_MODELS:
				sequence_SeparateModels(context, (SeparateModels) semanticObject); 
				return; 
			case ArchitecturePackage.SOURCE_MODEL_SELECTOR:
				sequence_SourceModelSelector(context, (SourceModelSelector) semanticObject); 
				return; 
			case ArchitecturePackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case ArchitecturePackage.TARGET_MODEL:
				sequence_TargetModel(context, (TargetModel) semanticObject); 
				return; 
			case ArchitecturePackage.TRACE_MODEL:
				sequence_TraceModel(context, (TraceModel) semanticObject); 
				return; 
			case ArchitecturePackage.TRACE_MODEL_REFERENCE:
				sequence_TraceModelReference(context, (TraceModelReference) semanticObject); 
				return; 
			case ArchitecturePackage.WEAVER:
				sequence_Weaver(context, (Weaver) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ConstraintExpression returns ArrayLiteral
	 *     ConstraintExpression.ConstraintExpression_1_0_0_0 returns ArrayLiteral
	 *     CompareExpression returns ArrayLiteral
	 *     CompareExpression.CompareExpression_1_0_0_0 returns ArrayLiteral
	 *     BasicConstraint returns ArrayLiteral
	 *     Operand returns ArrayLiteral
	 *     Literal returns ArrayLiteral
	 *     ArrayLiteral returns ArrayLiteral
	 *
	 * Constraint:
	 *     (literals+=Literal literals+=Literal*)
	 */
	protected void sequence_ArrayLiteral(ISerializationContext context, ArrayLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintExpression returns BooleanLiteral
	 *     ConstraintExpression.ConstraintExpression_1_0_0_0 returns BooleanLiteral
	 *     CompareExpression returns BooleanLiteral
	 *     CompareExpression.CompareExpression_1_0_0_0 returns BooleanLiteral
	 *     BasicConstraint returns BooleanLiteral
	 *     Operand returns BooleanLiteral
	 *     Literal returns BooleanLiteral
	 *     BooleanLiteral returns BooleanLiteral
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_BooleanLiteral(ISerializationContext context, BooleanLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.BOOLEAN_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.BOOLEAN_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanLiteralAccess().getValueBOOLEANTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintExpression returns CompareExpression
	 *     ConstraintExpression.ConstraintExpression_1_0_0_0 returns CompareExpression
	 *     CompareExpression returns CompareExpression
	 *
	 * Constraint:
	 *     (left=CompareExpression_CompareExpression_1_0_0_0 comparator=Comparator right=BasicConstraint)
	 */
	protected void sequence_CompareExpression(ISerializationContext context, CompareExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.COMPARE_EXPRESSION__COMPARATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.COMPARE_EXPRESSION__COMPARATOR));
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompareExpressionAccess().getCompareExpressionLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCompareExpressionAccess().getComparatorComparatorEnumRuleCall_1_0_0_1_0(), semanticObject.getComparator());
		feeder.accept(grammarAccess.getCompareExpressionAccess().getRightBasicConstraintParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintExpression returns ConstraintExpression
	 *
	 * Constraint:
	 *     (left=ConstraintExpression_ConstraintExpression_1_0_0_0 operator=LogicOperator right=ConstraintExpression)
	 */
	protected void sequence_ConstraintExpression(ISerializationContext context, ConstraintExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.CONSTRAINT_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintExpressionAccess().getConstraintExpressionLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getConstraintExpressionAccess().getOperatorLogicOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getConstraintExpressionAccess().getRightConstraintExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintExpression returns FloatLiteral
	 *     ConstraintExpression.ConstraintExpression_1_0_0_0 returns FloatLiteral
	 *     CompareExpression returns FloatLiteral
	 *     CompareExpression.CompareExpression_1_0_0_0 returns FloatLiteral
	 *     BasicConstraint returns FloatLiteral
	 *     Operand returns FloatLiteral
	 *     Literal returns FloatLiteral
	 *     FloatLiteral returns FloatLiteral
	 *
	 * Constraint:
	 *     value=FLOAT
	 */
	protected void sequence_FloatLiteral(ISerializationContext context, FloatLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.FLOAT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.FLOAT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFloatLiteralAccess().getValueFLOATTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GecoModel returns GecoModel
	 *
	 * Constraint:
	 *     (name=QualifiedName imports+=Import* registeredRootClass+=RegisteredRootClass* models+=ModelSequence* fragments+=Fragment*)
	 */
	protected void sequence_GecoModel(ISerializationContext context, GecoModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fragment returns Generator
	 *     AspectModel returns Generator
	 *     CombinedModel returns Generator
	 *     Generator returns Generator
	 *
	 * Constraint:
	 *     (
	 *         reference=[JvmType|ID] 
	 *         (sourceAuxModels+=SourceModelSelector sourceAuxModels+=SourceModelSelector*)? 
	 *         sourceModel=SourceModelSelector 
	 *         targetModel=TargetModel? 
	 *         targetTraceModel=TargetTraceModel? 
	 *         (sourceTraceModels+=TraceModelReference sourceTraceModels+=TraceModelReference*)?
	 *     )
	 */
	protected void sequence_Generator(ISerializationContext context, Generator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=[JvmType|QualifiedName]
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceJvmTypeQualifiedNameParserRuleCall_1_0_1(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintExpression returns InstanceOf
	 *     ConstraintExpression.ConstraintExpression_1_0_0_0 returns InstanceOf
	 *     CompareExpression returns InstanceOf
	 *     CompareExpression.CompareExpression_1_0_0_0 returns InstanceOf
	 *     BasicConstraint returns InstanceOf
	 *     Operand returns InstanceOf
	 *     InstanceOf returns InstanceOf
	 *
	 * Constraint:
	 *     type=[JvmType|ID]
	 */
	protected void sequence_InstanceOf(ISerializationContext context, InstanceOf semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.INSTANCE_OF__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.INSTANCE_OF__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInstanceOfAccess().getTypeJvmTypeIDTerminalRuleCall_1_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintExpression returns IntLiteral
	 *     ConstraintExpression.ConstraintExpression_1_0_0_0 returns IntLiteral
	 *     CompareExpression returns IntLiteral
	 *     CompareExpression.CompareExpression_1_0_0_0 returns IntLiteral
	 *     BasicConstraint returns IntLiteral
	 *     Operand returns IntLiteral
	 *     Literal returns IntLiteral
	 *     IntLiteral returns IntLiteral
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntLiteral(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.INT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.INT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModelSequence returns ModelSequence
	 *
	 * Constraint:
	 *     (modifier=ModelModifier type=ModelType models+=Model models+=Model*)
	 */
	protected void sequence_ModelSequence(ISerializationContext context, ModelSequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModelType returns ModelType
	 *
	 * Constraint:
	 *     (target=[RegisteredRootClass|ID] property=NodeProperty? collection?='[]'?)
	 */
	protected void sequence_ModelType(ISerializationContext context, ModelType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.MODEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.MODEL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintExpression returns Negation
	 *     ConstraintExpression.ConstraintExpression_1_0_0_0 returns Negation
	 *     CompareExpression returns Negation
	 *     CompareExpression.CompareExpression_1_0_0_0 returns Negation
	 *     BasicConstraint returns Negation
	 *     Negation returns Negation
	 *
	 * Constraint:
	 *     constraint=ConstraintExpression
	 */
	protected void sequence_Negation(ISerializationContext context, Negation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.NEGATION__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.NEGATION__CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegationAccess().getConstraintConstraintExpressionParserRuleCall_1_0(), semanticObject.getConstraint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NodeProperty returns NodeProperty
	 *     ConstraintExpression returns NodeProperty
	 *     ConstraintExpression.ConstraintExpression_1_0_0_0 returns NodeProperty
	 *     CompareExpression returns NodeProperty
	 *     CompareExpression.CompareExpression_1_0_0_0 returns NodeProperty
	 *     BasicConstraint returns NodeProperty
	 *     Operand returns NodeProperty
	 *
	 * Constraint:
	 *     (property=[JvmMember|ID] constraint=ConstraintExpression? subProperty=NodeProperty?)
	 */
	protected void sequence_NodeProperty(ISerializationContext context, NodeProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeSetRelation returns NodeSetRelation
	 *
	 * Constraint:
	 *     (sourceNodes+=NodeType sourceNodes+=NodeType* targetNodes+=NodeType targetNodes+=NodeType*)
	 */
	protected void sequence_NodeSetRelation(ISerializationContext context, NodeSetRelation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NodeType returns NodeType
	 *
	 * Constraint:
	 *     type=[JvmType|ID]
	 */
	protected void sequence_NodeType(ISerializationContext context, NodeType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.NODE_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.NODE_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNodeTypeAccess().getTypeJvmTypeIDTerminalRuleCall_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintExpression returns ParenthesisConstraint
	 *     ConstraintExpression.ConstraintExpression_1_0_0_0 returns ParenthesisConstraint
	 *     CompareExpression returns ParenthesisConstraint
	 *     CompareExpression.CompareExpression_1_0_0_0 returns ParenthesisConstraint
	 *     BasicConstraint returns ParenthesisConstraint
	 *     ParenthesisConstraint returns ParenthesisConstraint
	 *
	 * Constraint:
	 *     constraint=ConstraintExpression
	 */
	protected void sequence_ParenthesisConstraint(ISerializationContext context, ParenthesisConstraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.PARENTHESIS_CONSTRAINT__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.PARENTHESIS_CONSTRAINT__CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParenthesisConstraintAccess().getConstraintConstraintExpressionParserRuleCall_1_0(), semanticObject.getConstraint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RegisteredRootClass returns RegisteredRootClass
	 *
	 * Constraint:
	 *     (name=ID (importedNamespace=[JvmType|QualifiedName] | (isText?='text' extension=STRING)))
	 */
	protected void sequence_RegisteredRootClass(ISerializationContext context, RegisteredRootClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AspectModel returns SeparateModels
	 *     SeparateModels returns SeparateModels
	 *
	 * Constraint:
	 *     (pointcut=TargetModel advice=CombinedModel)
	 */
	protected void sequence_SeparateModels(ISerializationContext context, SeparateModels semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.SEPARATE_MODELS__POINTCUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.SEPARATE_MODELS__POINTCUT));
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.SEPARATE_MODELS__ADVICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.SEPARATE_MODELS__ADVICE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSeparateModelsAccess().getPointcutTargetModelParserRuleCall_1_0(), semanticObject.getPointcut());
		feeder.accept(grammarAccess.getSeparateModelsAccess().getAdviceCombinedModelParserRuleCall_3_0(), semanticObject.getAdvice());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SourceModelSelector returns SourceModelSelector
	 *
	 * Constraint:
	 *     (reference=[Model|ID] constraint=ConstraintExpression? property=NodeProperty?)?
	 */
	protected void sequence_SourceModelSelector(ISerializationContext context, SourceModelSelector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintExpression returns StringLiteral
	 *     ConstraintExpression.ConstraintExpression_1_0_0_0 returns StringLiteral
	 *     CompareExpression returns StringLiteral
	 *     CompareExpression.CompareExpression_1_0_0_0 returns StringLiteral
	 *     BasicConstraint returns StringLiteral
	 *     Operand returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AspectModel returns TargetModel
	 *     CombinedModel returns TargetModel
	 *     TargetModel returns TargetModel
	 *
	 * Constraint:
	 *     reference=[Model|ID]
	 */
	protected void sequence_TargetModel(ISerializationContext context, TargetModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.TARGET_MODEL__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.TARGET_MODEL__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTargetModelAccess().getReferenceModelIDTerminalRuleCall_1_0_1(), semanticObject.getReference());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TargetTraceModel returns TraceModelReference
	 *     TraceModelReference returns TraceModelReference
	 *
	 * Constraint:
	 *     traceModel=[TraceModel|ID]
	 */
	protected void sequence_TraceModelReference(ISerializationContext context, TraceModelReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ArchitecturePackage.Literals.TRACE_MODEL_REFERENCE__TRACE_MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ArchitecturePackage.Literals.TRACE_MODEL_REFERENCE__TRACE_MODEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTraceModelReferenceAccess().getTraceModelTraceModelIDTerminalRuleCall_0_1(), semanticObject.getTraceModel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TargetTraceModel returns TraceModel
	 *     TraceModel returns TraceModel
	 *
	 * Constraint:
	 *     (name=ID nodeSetRelations+=NodeSetRelation+)
	 */
	protected void sequence_TraceModel(ISerializationContext context, TraceModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Fragment returns Weaver
	 *     Weaver returns Weaver
	 *
	 * Constraint:
	 *     (reference=[JvmType|ID] sourceModel=SourceModelSelector? aspectModel=AspectModel targetModel=TargetModel?)
	 */
	protected void sequence_Weaver(ISerializationContext context, Weaver semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
